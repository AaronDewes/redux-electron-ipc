var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};function r(e={}){if("object"!=typeof e)throw new TypeError(`createIpc expects an events object as its first parameter, you passed type "${typeof e}"`);return Object.keys(e).forEach((t=>{if("function"!=typeof e[t])throw new TypeError(`Each key in createIpc's events object must be a dispatch-able function, key "${t}" is of type "${typeof e[t]}"`)})),({dispatch:t})=>(Object.keys(e).forEach((r=>{window.ipcRenderer.on(r,(function(){t(e[r](...arguments))}))})),function(e){return function(t){return t.type.startsWith("@@IPC")&&window.ipcRenderer.send(t.channel,...t.args||[]),e(t)}})}function n(e){return{type:"@@IPC",channel:e,args:Array.prototype.slice.call(arguments,1)}}e.d(t,{Z:()=>r,l:()=>n});var o=t.Z,c=t.l;export{o as default,c as send};